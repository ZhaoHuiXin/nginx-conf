## nginx 运行于企业内网的最外层，属于边缘节点，处理的流量是其他应用服务器处理流量的数倍甚至是几个数量级。

## 考虑几个问题
	1、为什么nginx使用master、worker这种架构模型
	2、为什么worker的个数要和CPU的个数相匹配

## nginx的内部有3个大的状态机：
	1、传输层状态机
	2、HTTP状态机
	3、MAIL状态机

## nginx核心是用非阻塞事件驱动epoll处理引擎
	使用异步处理引擎通常都是用状态机将请求正确的识别和处理

## 单进程结构：只适用于开发和调试

kill -QUIT 主进程号 优雅退出
kill -TERM/INT 主进程号 快速定制
kill -HUP 平滑重启
kill -USR2 旧版本的主进程号或进程文件名  平滑升级
pkill -9 nginx 强制停止Nginx

## nginx进程管理：信号
	MASTER进程：
		1、mater进程监控worker进程：
			当worker进程终止的时候，会向master进程发送 CHLD信号
		2、通过接收信号，管理worker进程：
		-	TERM, INT 立刻停止nginx进程
		-	QUIT 优雅的推出nginx进程，慢慢的停，不会向用户发送立刻结束连接
		-	HUP 重载配置文件
		-	USR1 重新打开日志文件，做日志文件的切割
			- 表示可以使用nginx命令行加特定的命令直接向master进程发送的
		*	USR2 （热部署时使用）
		*	WINCH	（热部署时使用）
			* 只能通过kill（linux的命令行）直接向master进程发送信号，
			就是说得找到master进程所在的pid，才能发送信号
	WORKER进程：
		1、接收信号：
			-	TERM, INT 立刻停止nginx进程
			-	QUIT 优雅的推出nginx进程，慢慢的停，不会向用户发送立刻结束连接
			-	HUP 重载配置文件
			-	USR1 重新打开日志文件，做日志文件的切割
		通常不对worker进程直接发送信号，希望由master进程管理worker进程
	NGINX命令行：
		logs下的nginx.pid记录nginx的master进程的pid，此时使用 nginx -s 命令行（工具命令行）的时候，它就会读取nginx.pid文件中的master进程的pid，向此pid的master进程发送信号
		nginx命令行命令，对应kill信号：
			1、reload：HUP
			2、reopen：USR1
			3、stop：TERM/INT
			4、quit：QUIT

## reload流程（更改配置文件后）
	1、向master进程发送HUP信号（reload命令）
	2、master进程检验配置语法是否正确
	3、master进程打开新的监听端口（是更改后的配置文件中存在之前配置文件没有的监听端口，是可能引入的新的端口）
	4、master进程用新配置文件启动新的worker子进程
	5、master进程向老worker子进程发送QUIT信号（优雅的关闭）
	6、老worker进程关闭监听句柄，处理完当前连接后结束进程，新的连接只会到新的子进程。
	* 新的nginx中有woker shutdown timeout，定时器到时见了如果老的worker还没退出就强制关闭

## 热升级的完整流程（不停止服务的情况下更换binary文件）
	1、将旧版本Nginx文件替换成新的Nginx文件，新的binary文件configure必须与老的一致，否则无法替换（注意备份，新版linux须用cp -f才能替换掉）
	2、向master进程发送USR2信号
	3、老master进程修改pid文件名，加后缀.oldbin
	4、用新的Nginx文件启动新的master进程
	5、向老master进程发送WINCH信号，关闭老worker，通过老的master进程pid（此时老的master进程并没有退出）
	6、回滚：向老master发送HUP，向新master发送QUIT

## 优雅的关闭worker进程（主要针对HTTP请求）
	优雅的关闭是对worker进程而言的，因为worker进程才是真正处理请求的进程，就是worker进程可以识别出当前的连接没有在处理请求
	1、设置定时器（worker_shutdown_timeout），此时会设立一个标志位
	2、关闭监听句柄（保证所在进程不再处理新的连接）
	3、关闭空闲连接（看自己的连接池，关闭所有空闲连接）
	4、在循环中等待全部链接关闭（每发现一个请求处理完毕，就将它的连接关掉；如果等待超过定时器时间，剩下的连接会被强制关闭，立即停止）
	5、退出进程
	对有些请求，nginx做不到优雅的关闭：
		1、当nginx代理websocket协议时，在websocket后面进行通讯的frame增里面，nginx不解析增，此时无法优雅关闭
		2、nginx做TCP层或UDP层的反向代理的时候，无法识别一个请求经历多少报文，才算结束

## 网络收发与Nginx事件间的对应关系
	每个连接对应一个读、写事件
	网络传输：
		1、应用层
		2、传输层
		3、网络层
		4、链路层
		5、物理层
	1、请求建立TCP连接事件 -- 对于nginx是读事件，读请求报文，Accpet建立连接，*连接建立事件消费者
	2、TCP连接可读事件（发送了一个消息）-- 对nginx也是一个读事件，Read读消息，*读事件消费者
	3、TCP连接关闭事件（浏览器主动关掉）-- 对于nginx也是一个读事件，读取请求报文，*连接关闭事件消费者
	4、TCP连接可写事件（nginx向浏览器发送响应） -- 对nginx是写事件，Write写消息，*写事件消费者
	5、AIO(异步读磁盘成功事件) -- 对nginx是读事件，*异步读磁盘事件消费者
	nginx还是定时器事件消费者，并且定时器到期事件由以上事件触发
	当nginx需要向浏览器发送响应的时候，需要把消息写到操作系统中，操作系统将消息发送到网络中
	事件收集分发器，nginx是消费者

## 对于建立新连接，nginx在第三次握手时才感知到读事件，调用accept方法建立一个新连接

## nginx事件驱动模型
	NGINX EVENT LOOP
	1、nginx刚启动时处于wait for events on connections，此时是打开了端口，等待新的事件进来（如客户端向nginx发起连接），这一步对应epoll wait方法，nginx处于sleep进程状态；当操作系统收到了一个建立tcp连接的握手报文并且处理完握手流程以后，操作系统就会通知epoll wait阻塞方法，告诉它可以往下走了，同时唤醒nginx worker进程
	2、nginx找操作系统要事件，操作系统会把它准备好的事件发在“事件队列”中，nginx从事件队列中可以一个一个获取到要处理的事件（如建立连接、收到tcp的请求报文等），
	3、处理事件：
		- 有处理时间（如60s，60s内浏览器不向nginx发送请求的话，即时间队列为空，此时nginx会关掉连接）
		- 如收到完整的http请求，可以生成http响应了，向操作系统的写缓存里，将响应信息写进去，要求操作系统尽快把写的内容发送到浏览器上，此时nginx期待一个写事件（也就是处理事件的过程中可能会产生新的事件，生成新的事件队列）
	4、所有事件处理完成，会返回wait for events on connections 状态

	若步骤2中有事件大量占用cpu导致其后事件被阻塞超时，nginx是不能容忍的，所以许多第三方模块会分段占用cpu

## epoll的优劣及原理
	- select和poll每次都要将所有的连接扔给操作系统判断哪些是活跃的连接
	- epoll维护了eventpoll，每次取活跃连接只需遍历一个链表(rdlink)，链表中只有活跃连接；
	- epoll对于处理事件时产生的事件（如处理连接请求，又产生了读事件或写事件）,新添加的事件只会放到一个红黑树中，是一个二叉平衡树，插入效率logN；如果现在不想处理读写事件，只需从二叉平衡树中移除一个节点即可，同样logN

## Nginx的请求切换
	- apache等，通过进程间切换来处理任务，每次进程间切换时间大概5微秒，并发量大时切换时间成指数倍增长，传统的web服务依赖操作系统的进程调度方法实现他的并发连接数，而操作系统的进程调度仅仅适用于很少量的进程间切换（几百、几千）
	- nginx，当一个请求处理事件不满足的情况下，在用户态直接切换到下一个请求，这样就没有了进程间切换的成本（因为网络事件不满足）；除非是nginx worker所使用的时间片已经到了，而时间片的长度一般是5ms到800ms，所以在nginx的worker配置上往往把它的优先级加到最高，比如-19，优先级比较高的时候往往操作系统给分配的时间片是比较大的，这样nginx才能比较好的在用户态完成请求切换，使得CPU少做无用功。

## 同步&异步，阻塞&非阻塞
	- 阻塞是指操作系统或底层C库提供的方法，或者是一个系统调用，也就是说调用一个方法的时候，这个方法可能会导致进程进入sleep状态（当前的操作状态不满足的情况下，操作系统主动从当前进程切换到另外一个进程来使用当前CPU）；
	- 非阻塞方法指我们调用一个方法，永远不会因为当我们时间片未用完时，把我们的进程主动切换掉
	- 同步异步是从调用方式而言，从业务逻辑这样的角度
	- 阻塞调用，会产生进程主动切换，如accpet，如果队列为空，就等待accept队列不为空
	- 非阻塞调用，由代码决定是否切换新任务，如果accept队列为空时等待还是立刻返回
	非阻塞调用下的同步和异步

## nginx的模块究竟是什么
	使用的模块须编译进Nginx；
	了解模块提供哪些配置项；
	了解模块何时被使用；
	知道模块提供了哪些变量；
	1、确定模块确实被编译进nginx中：
		./configure后，进入objs目录，查看ngx_modules.c，找到数组*ngx_modules[]，它包含了所有编译进nginx中的模块。
	2、查看模块提供哪些指令：
		对于官方文档中没有的模块，查看模块的源代码，src/目录下找到对应模块的.c源文件，在源文件中搜索ngx_command_t，它是模块中唯一的，并且是每个模块必须具备的一个结构体，它是一个数组，数组中每一个成员是它支持的指令名，指令名后是它可使用的参数，还包括了参数的类型，是空间？时间类型？
	3、ngx_module_t是通用的模块结构体（它包括nginx_command_t），但是有很多不同的应用（如http，如stream）；每类应用又包含许多不同的模块（子模块，子模块可以定义新的规则，但都得遵循ngx_module_t），
	4、ngx模块高内聚，相应独立的功能是在同一模块代码中的；
	5、ngx抽象做的非常好，mgx_module_t定义了
		- 所有的配置
		- 启停回调方法master刚刚启动的时候，worker将要启动的时候，worker进程将要退出的时候，master进程将要退出的时候，都要提供回调方法；也就是说任何一个第三方模块都有机会在master进程执行reload、。。。的时候加载自己的代码
		- 子模块抽象

##

	










